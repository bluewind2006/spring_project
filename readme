spring project

--------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.InvalidKeyException;
import java.util.Properties;
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.apache.commons.codec.DecoderException;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Hex;

public class Aes128 {
    private final SecretKey keySpec;
    private final IvParameterSpec ivSpec;

    public Aes128(String keyFile, String keyName) throws IOException, InvalidKeyException, DecoderException {
        File keyStore = new File(keyFile);
        FileInputStream fis = null;
        String secretKey = null;
        try {
            try {
                fis = new FileInputStream(keyStore);
                Properties props = new Properties();
                props.load(fis);
                secretKey = props.getProperty(keyName);
            } catch (Exception ex) {
                ex.printStackTrace();
                System.exit(0);
                fis.close();
            }
            if (secretKey == null || secretKey.trim().contentEquals("")) {
                throw new Exception(String.valueOf(keyName) + "으로 설정된 key가 존재하지 않습니다.");
            }
            fis.close();
            byte[] secretKeyBytes = Hex.decodeHex(secretKey);
            if (secretKeyBytes.length != 16) {
                throw new InvalidKeyException("Invalid key (key length is not valid) ");
            }
            byte[] ivBytes = new byte[16];
            System.arraycopy(secretKeyBytes, 0, ivBytes, 0, 16);
            this.keySpec = new SecretKeySpec(secretKeyBytes, "AES");
            this.ivSpec = new IvParameterSpec(ivBytes);
        } catch (Throwable th) {
            fis.close();
            throw th;
        }
    }

    public Aes128(String secretKey) throws IOException, InvalidKeyException, DecoderException {
        byte[] secretKeyBytes = Hex.decodeHex(secretKey);
        if (secretKeyBytes.length != 16) {
            throw new InvalidKeyException("Invalid key (key length is not valid) ");
        }
        byte[] ivBytes = new byte[16];
        System.arraycopy(secretKeyBytes, 0, ivBytes, 0, 16);
        this.keySpec = new SecretKeySpec(secretKeyBytes, "AES");
        this.ivSpec = new IvParameterSpec(ivBytes);
    }

    public String encrypt(String plainStr) throws CryptoException {
        if (plainStr == null) {
            return null;
        }
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(1, this.keySpec, this.ivSpec);
            byte[] encrypted = cipher.doFinal(plainStr.getBytes("UTF-8"));
            String encryptedStr = new String(Base64.encodeBase64(encrypted));
            return encryptedStr;
        } catch (Exception ex) {
            throw new CryptoException(ex.getMessage());
        }
    }

    public String decrypt(String encryptedStr) throws CryptoException {
        if (encryptedStr == null) {
            return null;
        }
        try {
            Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipher.init(2, this.keySpec, this.ivSpec);
            byte[] byteStr = Base64.decodeBase64(encryptedStr.getBytes("UTF-8"));
            String decryptedStr = new String(cipher.doFinal(byteStr), "UTF-8");
            return decryptedStr;
        } catch (Exception ex) {
            throw new CryptoException(ex.getMessage());
        }
    }
}

---------------------------------
public class CryptoException extends Exception {
    private static final long serialVersionUID = 6130083501304830088L;
    private String errorMsg;

    public CryptoException(String errorMsg) {
        super(errorMsg);
        setErrorMsg(errorMsg);
    }

    public String getErrorMsg() {
        return this.errorMsg;
    }

    public void setErrorMsg(String errorMsg) {
        this.errorMsg = errorMsg;
    }
}
----------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.RSAPublicKeySpec;
import java.security.spec.X509EncodedKeySpec;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Properties;
import javax.crypto.Cipher;
import org.apache.commons.codec.binary.Base64;

public class RSAManager {
    private String sPublicKey;
    private String sPrivateKey;
    private String publicKeyModulus;
    private String publicKeyExponent;

    public RSAManager() {
        this.sPublicKey = null;
        this.sPrivateKey = null;
        this.publicKeyModulus = null;
        this.publicKeyExponent = null;
    }

    public String getPublicKey() {
        return this.sPublicKey;
    }

    public String getPrivateKey() {
        return this.sPrivateKey;
    }

    public RSAManager(String keyFile, String publicKeyName, String privateKeyName) throws IOException {
        this.sPublicKey = null;
        this.sPrivateKey = null;
        this.publicKeyModulus = null;
        this.publicKeyExponent = null;
        File keyStore = new File(keyFile);
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(keyStore);
            Properties props = new Properties();
            props.load(fis);
            this.sPublicKey = props.getProperty(publicKeyName);
            this.sPrivateKey = props.getProperty(privateKeyName);
            if (this.sPublicKey == null || this.sPublicKey.trim().contentEquals("")) {
                throw new Exception(String.valueOf(this.sPublicKey) + "으로 설정된 key가 존재하지 않습니다.");
            }
            if (this.sPrivateKey == null || this.sPrivateKey.trim().contentEquals("")) {
                throw new Exception(String.valueOf(this.sPrivateKey) + "으로 설정된 key가 존재하지 않습니다.");
            }
        } catch (Exception ex) {
            ex.printStackTrace();
            System.exit(0);
        } finally {
            fis.close();
        }
    }

    public String encrypt(String value) throws Exception {
        byte[] bPublicKey2 = Base64.decodeBase64(this.sPublicKey.getBytes());
        KeyFactory keyFactory2 = KeyFactory.getInstance("RSA");
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bPublicKey2);
        PublicKey publicKey = keyFactory2.generatePublic(publicKeySpec);
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(1, publicKey);
        byte[] bCipher = cipher.doFinal(value.getBytes());
        String sCipherBase64 = Base64.encodeBase64String(bCipher);
        return sCipherBase64;
    }

    public String decrypt(String value) throws Exception {
        byte[] bPrivateKey = Base64.decodeBase64(this.sPrivateKey.getBytes());
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bPrivateKey);
        PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        byte[] bCipher = Base64.decodeBase64(value.getBytes());
        cipher.init(2, privateKey);
        byte[] bPlain = cipher.doFinal(bCipher);
        String sPlain = new String(bPlain);
        return sPlain;
    }

    public String encrypt(String sPublicKey, String value) throws Exception {
        byte[] bPublicKey2 = Base64.decodeBase64(sPublicKey.getBytes());
        KeyFactory keyFactory2 = KeyFactory.getInstance("RSA");
        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bPublicKey2);
        PublicKey publicKey = keyFactory2.generatePublic(publicKeySpec);
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(1, publicKey);
        byte[] bCipher = cipher.doFinal(value.getBytes());
        String sCipherBase64 = Base64.encodeBase64String(bCipher);
        return sCipherBase64;
    }

    public String decrypt(String sPrivateKey, String value) throws Exception {
        byte[] bPrivateKey = Base64.decodeBase64(sPrivateKey.getBytes());
        KeyFactory keyFactory = KeyFactory.getInstance("RSA");
        PKCS8EncodedKeySpec privateKeySpec = new PKCS8EncodedKeySpec(bPrivateKey);
        PrivateKey privateKey = keyFactory.generatePrivate(privateKeySpec);
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        byte[] bCipher = Base64.decodeBase64(value.getBytes());
        cipher.init(2, privateKey);
        byte[] bPlain = cipher.doFinal(bCipher);
        String sPlain = new String(bPlain);
        return sPlain;
    }

    public Map<String, String> generator() throws NoSuchAlgorithmException {
        SecureRandom secureRandom = new SecureRandom();
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048, secureRandom);
            KeyPair keyPair = keyPairGenerator.genKeyPair();
            PublicKey publicKey = keyPair.getPublic();
            PrivateKey privateKey = keyPair.getPrivate();
            byte[] bPublicKey = publicKey.getEncoded();
            String sPublicKey = Base64.encodeBase64String(bPublicKey);
            byte[] bPrivateKey = privateKey.getEncoded();
            String sPrivateKey = Base64.encodeBase64String(bPrivateKey);
            Map<String, String> rtnMap = new LinkedHashMap<>();
            rtnMap.put("sPublicKey", sPublicKey);
            rtnMap.put("sPrivateKey", sPrivateKey);
            return rtnMap;
        } catch (NoSuchAlgorithmException e) {
            throw e;
        }
    }

    public Map<String, String> makeModules() throws NoSuchAlgorithmException, InvalidKeySpecException {
        if (this.publicKeyExponent == null || this.publicKeyModulus == null) {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");
            byte[] bPublicKey = Base64.decodeBase64(this.sPublicKey.getBytes());
            X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(bPublicKey);
            PublicKey publicKey = keyFactory.generatePublic(publicKeySpec);
            RSAPublicKeySpec publicSpec = (RSAPublicKeySpec) keyFactory.getKeySpec(publicKey, RSAPublicKeySpec.class);
            BigInteger m = publicSpec.getModulus();
            BigInteger e = publicSpec.getPublicExponent();
            this.publicKeyModulus = Base64.encodeBase64String(m.toByteArray());
            this.publicKeyExponent = Base64.encodeBase64String(e.toByteArray());
        }
        Map<String, String> rtnMap = new LinkedHashMap<>();
        rtnMap.put("publicKeyModulus", this.publicKeyModulus);
        rtnMap.put("publicKeyExponent", this.publicKeyExponent);
        return rtnMap;
    }
}

-----------------------------------------------
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import org.apache.commons.codec.binary.Hex;


public class Sha256 {
    byte[] saltKeyBytes = null;

    public String encode(CharSequence rawPassword, String saltKey) throws Exception {
        if (saltKey == null || saltKey.trim().contentEquals("")) {
            throw new Exception("Salt key가 존재하지 않습니다.");
        }
        byte[] saltKeyBytes = Hex.decodeHex(saltKey);
        if (saltKeyBytes.length < 10) {
            throw new InvalidKeyException("Invalid key (salt key 10 byte 이상어야 합니다.) ");
        }
        MessageDigest md = MessageDigest.getInstance("SHA-256");
        md.update(saltKeyBytes);
        md.update(rawPassword.toString().getBytes(StandardCharsets.UTF_8));
        String encodedPassword = String.format("%040X", new BigInteger(1, md.digest()));
        return encodedPassword;
    }

    public String generateSaltKey() throws NoSuchAlgorithmException {
        KeyGenerator keygen = KeyGenerator.getInstance("AES");
        keygen.init(128);
        SecretKey skey = keygen.generateKey();
        return Hex.encodeHexString(skey.getEncoded());
    }
}
-----------------------------

import java.security.NoSuchAlgorithmException;
import java.security.spec.InvalidKeySpecException;

public class TestApp {
    public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException {
        RSAManager rsaManager = new RSAManager();
        System.out.println(rsaManager.generator());
        System.out.println(rsaManager.makeModules2());
    }
}
