spring project

주요 테스트 시나리오
AES 암호화 및 복호화:

AES 키 생성
평문을 AES로 암호화
암호문을 AES로 복호화
복호화된 텍스트가 원래 평문과 동일한지 확인
RSA 암호화 및 복호화:

RSA 키 쌍 생성
평문을 RSA 공개키로 암호화
암호문을 RSA 개인키로 복호화
복호화된 텍스트가 원래 평문과 동일한지 확인
SHA-256 해싱:

소금을 생성
평문을 소금과 함께 해시
해시된 값이 평문과 소금으로 검증되는지 확인

항목	Spring Security 5.x	Spring Security 6.x
지원 Java 버전	Java 8 및 11	Java 17 이상
Spring Boot 호환성	Spring Boot 2.x	Spring Boot 3.x
패키지 네임스페이스	javax 패키지 (javax.servlet, javax.validation 등)	jakarta 패키지 (jakarta.servlet, jakarta.validation 등)
구성 방식	XML 및 자바 기반 구성<br>WebSecurityConfigurerAdapter	주로 자바 기반 구성<br>SecurityFilterChain, SecurityConfigurer 사용
OAuth 2.0 및 OpenID Connect	기본적인 지원<br>다양한 인증 서버 및 리소스 서버 구성 가능	강화된 지원<br>더 많은 커스터마이제이션 옵션<br>OAuth 2.0 클라이언트 및 리소스 서버 설정 개선
Reactive Security	초기 지원	더욱 강화된 지원
비밀번호 인코딩 전략	DelegatingPasswordEncoder 사용	새로운 비밀번호 인코딩 전략 도입
기본 보안 설정	다양한 기본 보안 설정 제공	더 많은 기본 보안 헤더와 정책 추가
커스텀 필터 및 설정	기존 인프라스트럭처	더 유연해진 커스텀 필터 및 인프라스트럭처 설정
마이그레이션 가이드	-	Java 17 이상으로 업그레이드<br>javax에서 jakarta로 전환<br>WebSecurityConfigurerAdapter에서 SecurityFilterChain으로 전환<br>XML 기반 구성에서 자바 기반 구성으로 전환 권장


Spring Security 5.x와 6.x 사이의 기본 보안 설정 부분에서의 주요 변경 사항들을 자세히 설명하겠습니다.

기본 보안 설정 변경 사항
CSRF (Cross-Site Request Forgery) Protection
CORS (Cross-Origin Resource Sharing) 설정
Content Security Policy (CSP)
HTTP 헤더 보안
비밀번호 인코딩
1. CSRF Protection
Spring Security 5.x
5.x 버전에서는 CSRF 보호가 기본적으로 활성화되어 있습니다. 대부분의 애플리케이션에서는 기본 설정을 그대로 사용하지만, 필요에 따라 비활성화하거나 커스터마이즈할 수 있습니다.

java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable() // 필요에 따라 비활성화
        .authorizeRequests()
            .anyRequest().authenticated();
}
Spring Security 6.x
6.x 버전에서도 CSRF 보호는 기본적으로 활성화되어 있습니다. 그러나 Lambda DSL을 사용하여 보다 간단하게 설정할 수 있습니다.

java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable()) // 필요에 따라 비활성화
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests.anyRequest().authenticated()
        );
    return http.build();
}
2. CORS 설정
Spring Security 5.x
CORS 설정은 WebMvcConfigurer에서 설정하거나, HttpSecurity에서 직접 설정할 수 있습니다.

java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .cors().and()
        .authorizeRequests()
            .anyRequest().authenticated();
}

// 또는 WebMvcConfigurer에서 설정
@Bean
public WebMvcConfigurer corsConfigurer() {
    return new WebMvcConfigurer() {
        @Override
        public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping("/**").allowedOrigins("http://example.com");
        }
    };
}
Spring Security 6.x
Lambda DSL을 사용하여 CORS 설정을 보다 간단하게 정의할 수 있습니다.

java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .cors(withDefaults()) // 기본 설정 사용
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests.anyRequest().authenticated()
        );
    return http.build();
}

// 또는 별도의 구성 클래스에서 설정
@Bean
public CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration configuration = new CorsConfiguration();
    configuration.setAllowedOrigins(Arrays.asList("http://example.com"));
    configuration.setAllowedMethods(Arrays.asList("GET", "POST"));
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", configuration);
    return source;
}
3. Content Security Policy (CSP)
Spring Security 5.x
5.x 버전에서는 Content Security Policy를 수동으로 설정할 수 있습니다.

java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .headers()
            .contentSecurityPolicy("default-src 'self'; script-src 'self' 'unsafe-inline';");
}
Spring Security 6.x
6.x에서는 Lambda DSL을 사용하여 CSP를 설정할 수 있습니다.

java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .headers(headers -> 
            headers.contentSecurityPolicy(csp -> 
                csp.policyDirectives("default-src 'self'; script-src 'self' 'unsafe-inline';")
            )
        )
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests.anyRequest().authenticated()
        );
    return http.build();
}
4. HTTP 헤더 보안
Spring Security 5.x
기본적으로 Spring Security는 다양한 HTTP 헤더 보안을 제공하며, 필요에 따라 추가 설정이 가능합니다.

java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .headers()
            .xssProtection()
            .and()
            .frameOptions().sameOrigin();
}
Spring Security 6.x
Lambda DSL을 사용하여 동일한 설정을 보다 간단하게 정의할 수 있습니다.

java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .headers(headers -> 
            headers
                .xssProtection(withDefaults())
                .frameOptions(frameOptions -> frameOptions.sameOrigin())
        )
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests.anyRequest().authenticated()
        );
    return http.build();
}
5. 비밀번호 인코딩
Spring Security 5.x
5.x에서는 DelegatingPasswordEncoder를 사용하여 다양한 비밀번호 인코딩 방식을 지원합니다.

java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
Spring Security 6.x
6.x에서도 DelegatingPasswordEncoder를 사용하지만, 추가적인 비밀번호 인코딩 전략이 도입되었습니다.

java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
요약
Spring Security 6.x에서는 보안 설정을 보다 직관적이고 간결하게 정의할 수 있도록 Lambda DSL을 도입했습니다. CSRF 보호, CORS 설정, Content Security Policy, HTTP 헤더 보안, 비밀번호 인코딩 등 다양한 기본 보안 설정이 개선되었습니다. 이러한 변경 사항들은 최신 자바 버전 및 Jakarta EE 9와의 호환성을 높이고, 보안 설정을 보다 쉽게 관리할 수 있도록 도와줍니다.


Spring Security 6.x에서 추가된 비밀번호 인코딩 전략은 비밀번호 보안 강화를 위해 다양한 인코딩 방식을 제공합니다. 비밀번호 인코딩은 비밀번호를 안전하게 저장하고 비교하기 위해 필수적인 과정입니다. Spring Security는 기본적으로 DelegatingPasswordEncoder를 사용하여 여러 인코딩 방식을 지원합니다. 6.x 버전에서 추가된 비밀번호 인코딩 전략을 살펴보겠습니다.

1. DelegatingPasswordEncoder
DelegatingPasswordEncoder는 다양한 비밀번호 인코딩 방식을 지원하며, 인코딩된 비밀번호 앞에 접두사를 붙여 어떤 방식으로 인코딩되었는지 식별할 수 있도록 합니다. 기본적으로 bcrypt를 사용하지만, 다른 인코딩 방식도 쉽게 추가할 수 있습니다.

예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return PasswordEncoderFactories.createDelegatingPasswordEncoder();
}
2. Argon2PasswordEncoder
Spring Security 5.x에서는 bcrypt, pbkdf2, scrypt 등의 인코딩 방식을 지원했으나, 6.x에서는 Argon2PasswordEncoder가 추가되었습니다. Argon2는 현대적인 메모리-하드 해시 함수로서 비밀번호 해시화를 위한 강력한 옵션 중 하나입니다.

Argon2 인코더 설정 예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return new Argon2PasswordEncoder();
}
3. PBKDF2PasswordEncoder
PBKDF2는 Key Derivation Function의 한 종류로, 비밀번호 해시화를 위해 널리 사용됩니다. Spring Security 6.x에서는 PBKDF2PasswordEncoder의 기본 설정이 개선되었습니다.

PBKDF2 인코더 설정 예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return new Pbkdf2PasswordEncoder();
}
4. SCryptPasswordEncoder
SCrypt는 메모리 집약적인 해시 함수로, 특히 비밀번호 해시화에 적합합니다. Spring Security 6.x에서는 SCryptPasswordEncoder가 기본적으로 제공됩니다.

SCrypt 인코더 설정 예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return new SCryptPasswordEncoder();
}
5. NoOpPasswordEncoder
NoOpPasswordEncoder는 비밀번호를 인코딩하지 않고 그대로 저장합니다. 이는 실제 애플리케이션에서는 보안상 사용해서는 안 되지만, 테스트 용도로 사용할 수 있습니다.

NoOp 인코더 설정 예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
6. StandardPasswordEncoder
StandardPasswordEncoder는 SHA-256 해시 알고리즘을 기반으로 한 인코더로, 더 이상 권장되지는 않지만, 여전히 사용 가능합니다.

StandardPasswordEncoder 설정 예제
java
코드 복사
@Bean
public PasswordEncoder passwordEncoder() {
    return new StandardPasswordEncoder();
}
결론
Spring Security 6.x는 기존의 비밀번호 인코딩 전략을 유지하면서도 Argon2PasswordEncoder를 추가하여 더 강력하고 현대적인 인코딩 방식을 지원합니다. DelegatingPasswordEncoder를 통해 여러 인코딩 방식을 유연하게 사용할 수 있으며, 각 인코딩 방식은 특정 보안 요구 사항에 맞게 선택할 수 있습니다. 이로써 비밀번호 보안을 한층 더 강화할 수 있습니다.



Spring Security 5.x에서 6.x로의 마이그레이션에서 SecurityConfig와 관련된 주요 변경 사항은 다음과 같습니다.

주요 변경 사항
WebSecurityConfigurerAdapter 제거
구성 방식 변경 (Lambda DSL 사용)
HttpSecurity 구성 변경
패키지 네임스페이스 변경 (javax에서 jakarta로)
커스터마이징 옵션 확장
1. WebSecurityConfigurerAdapter 제거
Spring Security 5.x
5.x 버전에서는 WebSecurityConfigurerAdapter를 확장하여 보안 구성을 정의하는 것이 일반적이었습니다.

java
코드 복사
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests()
                .antMatchers("/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            .formLogin();
    }
}
Spring Security 6.x
6.x 버전에서는 WebSecurityConfigurerAdapter가 제거되었으며, 대신 SecurityFilterChain을 빈으로 정의하여 사용합니다.

java
코드 복사
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(authorizeRequests -> 
                authorizeRequests
                    .requestMatchers("/public/**").permitAll()
                    .anyRequest().authenticated()
            )
            .formLogin(withDefaults());
        
        return http.build();
    }
}
2. 구성 방식 변경 (Lambda DSL 사용)
6.x에서는 Lambda DSL을 사용하여 보안 구성을 보다 명확하고 간결하게 정의할 수 있습니다.

Spring Security 5.x
java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests()
            .antMatchers("/admin/**").hasRole("ADMIN")
            .antMatchers("/user/**").hasRole("USER")
            .anyRequest().authenticated()
        .and()
        .formLogin()
        .and()
        .logout();
}
Spring Security 6.x
java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests
                .requestMatchers("/admin/**").hasRole("ADMIN")
                .requestMatchers("/user/**").hasRole("USER")
                .anyRequest().authenticated()
        )
        .formLogin(withDefaults())
        .logout(withDefaults());
    
    return http.build();
}
3. HttpSecurity 구성 변경
HttpSecurity 구성 시 메소드 체이닝 대신 메소드 참조 방식이 도입되었습니다.

Spring Security 5.x
java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .csrf().disable()
        .authorizeRequests()
            .antMatchers("/api/**").hasRole("API_USER")
            .anyRequest().authenticated()
        .and()
        .httpBasic();
}
Spring Security 6.x
java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf.disable())
        .authorizeHttpRequests(authorizeRequests -> 
            authorizeRequests
                .requestMatchers("/api/**").hasRole("API_USER")
                .anyRequest().authenticated()
        )
        .httpBasic(withDefaults());
    
    return http.build();
}
4. 패키지 네임스페이스 변경 (javax에서 jakarta로)
6.x 버전부터는 Jakarta EE 9로 전환됨에 따라 패키지 네임스페이스가 javax에서 jakarta로 변경되었습니다. 예를 들어 javax.servlet 패키지는 jakarta.servlet로 대체됩니다.

5. 커스터마이징 옵션 확장
6.x에서는 다양한 보안 설정 옵션이 확장되었으며, 이를 통해 더 많은 커스터마이징이 가능합니다.

Spring Security 5.x
java
코드 복사
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .rememberMe()
            .tokenValiditySeconds(86400)
            .key("mySecretKey")
        .and()
        .sessionManagement()
            .maximumSessions(1)
            .expiredUrl("/session-expired.html");
}
Spring Security 6.x
java
코드 복사
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .rememberMe(rememberMe -> 
            rememberMe
                .tokenValiditySeconds(86400)
                .key("mySecretKey")
        )
        .sessionManagement(sessionManagement -> 
            sessionManagement
                .maximumSessions(1)
                .expiredUrl("/session-expired.html")
        );
    
    return http.build();
}
결론
Spring Security 6.x는 보안 구성을 더욱 직관적이고 간결하게 만들기 위해 여러 변경 사항을 도입했습니다. WebSecurityConfigurerAdapter의 제거, Lambda DSL의 도입, 패키지 네임스페이스 변경 등이 주요 변화입니다. 이러한 변경 사항들은 보안 구성을 보다 명확하게 하고, 최신 자바 버전 및 Jakarta EE 9와의 호환성을 높이는 데 중점을 두고 있습니다.
